###########

Phase 2

###########

This time breakpoint should be for phase 2. We already know phase 1's password. 
And will use it every time we run the bomb. So it is easier to use a .txt file and run with it.
In phase 2, we dont know what kind of password we have. It could be a string, a number or a combination of two numbers with a string 
so there is lots of possibilties.. But don't worry, it can be figured very easily. :)


(gdb) b phase_2
Breakpoint 1 at 0x400dc1
(gdb) r answers.txt
Starting program: /home/zeynep/Desktop/Project 2/bomb answers.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
123                                                     //lets try some number this number when it asks the input.

Breakpoint 1, 0x0000000000400dc1 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
=> 0x0000000000400dc1 <+0>:	push   %rbp
   0x0000000000400dc2 <+1>:	push   %rbx
   0x0000000000400dc3 <+2>:	sub    $0x28,%rsp
   0x0000000000400dc7 <+6>:	mov    %rsp,%rsi
   0x0000000000400dca <+9>:	callq  0x4012c0 <read_six_numbers>      //hey what six numbers?
   0x0000000000400dcf <+14>:	cmpl   $0x0,(%rsp)
   0x0000000000400dd3 <+18>:	jne    0x400ddc <phase_2+27>
   0x0000000000400dd5 <+20>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400dda <+25>:	je     0x400de1 <phase_2+32>
   0x0000000000400ddc <+27>:	callq  0x40129e <explode_bomb>
   0x0000000000400de1 <+32>:	mov    %rsp,%rbx
   0x0000000000400de4 <+35>:	lea    0x10(%rbx),%rbp
   0x0000000000400de8 <+39>:	jmp    0x400df3 <phase_2+50>
   0x0000000000400dea <+41>:	add    $0x4,%rbx
   0x0000000000400dee <+45>:	cmp    %rbp,%rbx
   0x0000000000400df1 <+48>:	je     0x400e04 <phase_2+67>
   0x0000000000400df3 <+50>:	mov    0x4(%rbx),%eax
   0x0000000000400df6 <+53>:	add    (%rbx),%eax
   0x0000000000400df8 <+55>:	cmp    %eax,0x8(%rbx)
   0x0000000000400dfb <+58>:	je     0x400dea <phase_2+41>
   0x0000000000400dfd <+60>:	callq  0x40129e <explode_bomb>
   0x0000000000400e02 <+65>:	jmp    0x400dea <phase_2+41>
   0x0000000000400e04 <+67>:	add    $0x28,%rsp
   0x0000000000400e08 <+71>:	pop    %rbx
   0x0000000000400e09 <+72>:	pop    %rbp
   0x0000000000400e0a <+73>:	retq   
End of assembler dump.

In this line, 
      0x0000000000400dca <+9>:	callq  0x4012c0 <read_six_numbers>
it is obvious that we are looking for some 6 numbers. Maybe they have an order.

Lets try one more time with 6 random numbers to understand clearly.
(gdb) b phase_2
Breakpoint 1 at 0x400dc1
(gdb) r answers.txt
Starting program: /home/zeynep/Desktop/Project 2/bomb answers.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
1 2 3 4 5 6                                            //new guess

Breakpoint 1, 0x0000000000400dc1 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
=> 0x0000000000400dc1 <+0>:	push   %rbp
   0x0000000000400dc2 <+1>:	push   %rbx
   0x0000000000400dc3 <+2>:	sub    $0x28,%rsp
   0x0000000000400dc7 <+6>:	mov    %rsp,%rsi
   0x0000000000400dca <+9>:	callq  0x4012c0 <read_six_numbers>
   0x0000000000400dcf <+14>:	cmpl   $0x0,(%rsp)                    //first number of rsp shows is zero or not? 
   0x0000000000400dd3 <+18>:	jne    0x400ddc <phase_2+27>
   0x0000000000400dd5 <+20>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400dda <+25>:	je     0x400de1 <phase_2+32>
   0x0000000000400ddc <+27>:	callq  0x40129e <explode_bomb>
   0x0000000000400de1 <+32>:	mov    %rsp,%rbx
   0x0000000000400de4 <+35>:	lea    0x10(%rbx),%rbp
   0x0000000000400de8 <+39>:	jmp    0x400df3 <phase_2+50>
   0x0000000000400dea <+41>:	add    $0x4,%rbx
   0x0000000000400dee <+45>:	cmp    %rbp,%rbx
   0x0000000000400df1 <+48>:	je     0x400e04 <phase_2+67>
   0x0000000000400df3 <+50>:	mov    0x4(%rbx),%eax
   0x0000000000400df6 <+53>:	add    (%rbx),%eax
   0x0000000000400df8 <+55>:	cmp    %eax,0x8(%rbx)
   0x0000000000400dfb <+58>:	je     0x400dea <phase_2+41>
   0x0000000000400dfd <+60>:	callq  0x40129e <explode_bomb>
   0x0000000000400e02 <+65>:	jmp    0x400dea <phase_2+41>
   0x0000000000400e04 <+67>:	add    $0x28,%rsp
   0x0000000000400e08 <+71>:	pop    %rbx
   0x0000000000400e09 <+72>:	pop    %rbp
   0x0000000000400e0a <+73>:	retq   
End of assembler dump.

first part is the inital values and creating the stack with those.
When we jump directly to callq  0x4012c0 <read_six_numbers>, %rax will keep the input that we enter. Lets check it.

(gdb) print $rax
$3 = 6305744
(gdb) x/s 6305744
0x6037d0 <input_strings+80>:	"1 2 3 4 5 6"

















